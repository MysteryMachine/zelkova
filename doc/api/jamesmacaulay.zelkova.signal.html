<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><title>jamesmacaulay.zelkova.signal documentation</title></head><body><header><section class="title"><h1><a href="index.html">Zelkova Api Documentation</a></h1></section><small>Version: 0.4.0</small></header><section class="container"><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>alandipert</span></div></div></li><li class="depth-2"><a href="alandipert.kahn.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>kahn</span></div></a></li><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>jamesmacaulay</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>async-tools</span></div></div></li><li class="depth-3 branch"><a href="jamesmacaulay.async-tools.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch"><a href="jamesmacaulay.async-tools.core-test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core-test</span></div></a></li><li class="depth-3"><a href="jamesmacaulay.async-tools.test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>test</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree" style="top: -114px;"><span class="top" style="height: 123px;"></span><span class="bottom"></span></span><span>zelkova</span></div></div></li><li class="depth-3"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>impl</span></div></div></li><li class="depth-4 branch"><a href="jamesmacaulay.zelkova.impl.signal.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>signal</span></div></a></li><li class="depth-4 branch"><a href="jamesmacaulay.zelkova.impl.signal-test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>signal-test</span></div></a></li><li class="depth-4"><a href="jamesmacaulay.zelkova.impl.time.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>time</span></div></a></li><li class="depth-3 branch"><a href="jamesmacaulay.zelkova.keyboard.html"><div class="inner"><span class="tree" style="top: -114px;"><span class="top" style="height: 123px;"></span><span class="bottom"></span></span><span>keyboard</span></div></a></li><li class="depth-3 branch"><a href="jamesmacaulay.zelkova.mouse.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mouse</span></div></a></li><li class="depth-3 branch current"><a href="jamesmacaulay.zelkova.signal.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>signal</span></div></a></li><li class="depth-3 branch"><a href="jamesmacaulay.zelkova.signal-test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>signal-test</span></div></a></li><li class="depth-3 branch"><a href="jamesmacaulay.zelkova.time.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>time</span></div></a></li><li class="depth-3"><a href="jamesmacaulay.zelkova.window.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>window</span></div></a></li></ul></div><section class="namespace-docs" id="content"><h2 class="anchor" id="top">jamesmacaulay.zelkova.signal</h2><div class="doc"><div class="markdown"><p>This is Zelkova&rsquo;s core namespace.</p></div></div><div class="public anchor" id="var-activate-when"><h3><a href="#var-activate-when">activate-when</a></h3><div class="usage"><code>(activate-when switch-sig value-sig)</code></div><div class="doc"><div class="markdown"><p>Returns a transformation of <code>value-sig</code> whose entire graph of signal dependencies—aside from input nodes—is skipped unless <code>switch-sig</code>&rsquo;s state is truthy. This is accomplished by walking <code>value-sig</code>&rsquo;s graph and wrapping its input signals with <code>keep-when</code>. The intial value of a signal returned from <code>activate-when</code> is always equal to the initial value of <code>value-sig</code>.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L367">view source</a></div></div><div class="public anchor" id="var-async"><h3><a href="#var-async">async</a></h3><div class="usage"><code>(async source)</code></div><div class="doc"><div class="markdown"><p>Returns an &ldquo;asynchronous&rdquo; version of <code>source</code>, splitting off a new subgraph which does not maintain consistent event ordering relative to the main graph. In exchange, signals which depend on an <code>async</code> signal don&rsquo;t have to wait for the <code>source</code> to finish computing new values. This function is mainly useful in multithreaded environments when you don&rsquo;t want a slow computation to block the whole graph.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L208">view source</a></div></div><div class="public anchor" id="var-combine"><h3><a href="#var-combine">combine</a></h3><div class="usage"><code>(combine sigs)</code></div><div class="doc"><div class="markdown"><p>Combines a sequence of signals into a signal of vectors. Equivalent to <code>(signal/map vector sig1, sig2, ...)</code></p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L278">view source</a></div></div><div class="public anchor" id="var-constant"><h3><a href="#var-constant">constant</a></h3><div class="usage"><code>(constant x)</code></div><div class="doc"><div class="markdown"><p>Returns a constant signal of the given value.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L53">view source</a></div></div><div class="public anchor" id="var-count"><h3><a href="#var-count">count</a></h3><div class="usage"><code>(count sig)</code></div><div class="doc"><div class="markdown"><p>Returns a signal whose values are the number of fresh values emitted so far from <code>sig</code>. Repeated equal values will be counted so long as they are fresh, so if you don&rsquo;t want to count repeats then you need to <code>(count (drop-repeats sig))</code> instead.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L296">view source</a></div></div><div class="public anchor" id="var-count-if"><h3><a href="#var-count-if">count-if</a></h3><div class="usage"><code>(count-if pred sig)</code></div><div class="doc"><div class="markdown"><p>Like <code>count</code>, but only increments the counter if the fresh value emitted from <code>sig</code> satisfies the predicate funtion <code>pred</code>. For example, <code>(count-if odd? numbers)</code> returns a signal of how many times the <code>numbers</code> signal emitted an odd number.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L303">view source</a></div></div><div class="public anchor" id="var-drop-if"><h3><a href="#var-drop-if">drop-if</a></h3><div class="usage"><code>(drop-if pred sig)</code><code>(drop-if pred base sig)</code></div><div class="doc"><div class="markdown"><p>Like <code>keep-if</code>, but drops values which match the predicate.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L339">view source</a></div></div><div class="public anchor" id="var-drop-repeats"><h3><a href="#var-drop-repeats">drop-repeats</a></h3><div class="usage"><code>(drop-repeats sig)</code></div><div class="doc"><div class="markdown"><p>Returns a signal which relays values of <code>sig</code>, but drops repeated equal values.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L165">view source</a></div></div><div class="public anchor" id="var-drop-when"><h3><a href="#var-drop-when">drop-when</a></h3><div class="usage"><code>(drop-when switch-sig value-sig)</code><code>(drop-when switch-sig base value-sig)</code></div><div class="doc"><div class="markdown"><p>Like <code>keep-when</code>, but only relays values when <code>switch-sig</code> is falsy.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L360">view source</a></div></div><div class="public anchor" id="var-foldp"><h3><a href="#var-foldp">foldp</a></h3><div class="usage"><code>(foldp f base source)</code></div><div class="doc"><div class="markdown"><p>Create a past-dependent signal (&ldquo;fold into the past&rdquo;). The values of a <code>foldp</code> signal are obtained by calling <code>f</code> with two arguments: the current value of the <code>source</code> signal, and the previous value of the new <code>foldp</code> signal (acting as the &ldquo;accumulator&rdquo;). <code>init</code> provides the initial value of the new signal, and therefore acts as the seed accumulator.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L151">view source</a></div></div><div class="public anchor" id="var-indexed-updates"><h3><a href="#var-indexed-updates">indexed-updates</a></h3><div class="usage"><code>(indexed-updates signal-map)</code></div><div class="doc"><div class="markdown"><p>Takes a map whose values are signals, to be used as a template. Returns a new signal whose values are maps that include an entry for every signal in <code>signal-map</code> with a fresh value. For example, assuming that <code>signal-map</code> is:</p>
<pre><code>{:a sig-a
 :b sig-b
 :c sig-c}
</code></pre><p>Then when <code>sig-a</code> has a fresh value of &ldquo;foo&rdquo;, <code>sig-b</code>&rsquo;s value is cached, and <code>sig-c</code> has a fresh value of &ldquo;bar&rdquo;, then the <code>indexed-updates</code> signal would emit <code>{:a &quot;foo&quot; :c &quot;bar&quot;}. When none of the signals have fresh values, no
value is emitted from the</code>indexed-updates` signal. This means that this signal never emits an empty map.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L122">view source</a></div></div><div class="public anchor" id="var-input"><h3><a href="#var-input">input</a></h3><div class="usage"><code>(input init)</code><code>(input init topic)</code><code>(input init topic value-source)</code></div><div class="doc"><div class="markdown"><p>Returns an input signal with initial value <code>init</code>. The signal propagates values from events which match some <code>topic</code>. An asynchronous <code>value-source</code> may be provided, which will be used as the default value source for the given event <code>topic</code>. <code>value-source</code> may take the following forms:</p>
<ul>
  <li>a function taking a live graph and an options map, and returns a channel of values</li>
  <li>a channel of values</li>
  <li>a mult of some such value channel</li>
</ul></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L14">view source</a></div></div><div class="public anchor" id="var-keep-if"><h3><a href="#var-keep-if">keep-if</a></h3><div class="usage"><code>(keep-if pred sig)</code><code>(keep-if pred base sig)</code></div><div class="doc"><div class="markdown"><p>Returns a signal which relays values from <code>sig</code>, but discards any which don&rsquo;t match the given predicate function <code>pred</code>. If a <code>base</code> value is provided, it will be the initial value of the returned signal if the initial value of <code>sig</code> does not match the predicate. If no <code>base</code> is provided then the returned signal will always have the same initial value as <code>sig</code>, even if it does not match the predicate.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L321">view source</a></div></div><div class="public anchor" id="var-keep-if-msg-xform"><h3><a href="#var-keep-if-msg-xform">keep-if-msg-xform</a></h3><div class="usage"><code>(keep-if-msg-xform pred)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L313">view source</a></div></div><div class="public anchor" id="var-keep-when"><h3><a href="#var-keep-when">keep-when</a></h3><div class="usage"><code>(keep-when switch-sig value-sig)</code><code>(keep-when switch-sig base value-sig)</code></div><div class="doc"><div class="markdown"><p>Returns a new signal which relays values from <code>value-sig</code>, but only when the current value of <code>switch-sig</code> is truthy.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L346">view source</a></div></div><div class="public anchor" id="var-log"><h3><a href="#var-log">log</a></h3><div class="usage"><code>(log sig)</code></div><div class="doc"><div class="markdown"><p>A little convenience helper which logs signal values with <code>pr</code> before propagating them unchanged.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L388">view source</a></div></div><div class="public anchor" id="var-map"><h3><a href="#var-map">map</a></h3><div class="usage"><code>(map f &amp; sources)</code></div><div class="doc"><div class="markdown"><p>Takes a mapping function <code>f</code> and any number of signal <code>sources</code>, and returns a signal of values obtained by applying <code>f</code> to the values from the source signals.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L106">view source</a></div></div><div class="public anchor" id="var-mapseq"><h3><a href="#var-mapseq">mapseq</a></h3><div class="usage"><code>(mapseq f sources)</code></div><div class="doc"><div class="markdown"><p>Takes a mapping function <code>f</code> and a sequence of signal <code>sources</code>, and returns a signal of values obtained by applying <code>f</code> to the values from the source signals.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L85">view source</a></div></div><div class="public anchor" id="var-merge"><h3><a href="#var-merge">merge</a></h3><div class="usage"><code>(merge &amp; sigs)</code></div><div class="doc"><div class="markdown"><p>Takes any number of source signals <code>sigs</code>, and returns a new signal which relays fresh values from all of the source signals. When more than one source has fresh values at the same time, the first (leftmost) signal will take precedence and the other values will be discarded. The initial value of the returned signal is equal to the initial value of the first source signal.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L269">view source</a></div></div><div class="public anchor" id="var-mergeseq"><h3><a href="#var-mergeseq">mergeseq</a></h3><div class="usage"><code>(mergeseq sigs)</code></div><div class="doc"><div class="markdown"><p>Takes a sequence of signals <code>sigs</code>, and returns a new signal which relays fresh values from all of the source signals. When more than one source has fresh values at the same time, the first (leftmost) signal in <code>sigs</code> will take precedence and the other values will be discarded. The initial value of the returned signal is equal to the initial value of the first source signal.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L256">view source</a></div></div><div class="public anchor" id="var-pipe-to-atom"><h3><a href="#var-pipe-to-atom">pipe-to-atom</a></h3><div class="usage"><code>(pipe-to-atom x)</code><code>(pipe-to-atom x atm)</code><code>(pipe-to-atom x atm ks)</code></div><div class="doc"><div class="markdown"><p>Pipes fresh values from a live graph into an atom. If <code>x</code> is a signal, it is <code>spawn</code>ed as a live graph first. If no atom is provided, then a new atom is created which takes its initial value from that of the given signal or graph. If an existing atom is provided along with a sequence of keys <code>ks</code>, then fresh values will be inserted into the atom&rsquo;s value using <code>swap!</code> with <code>assoc-in</code>. If <code>ks</code> is not present, then the whole atom value is replaced with <code>reset!</code>.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L398">view source</a></div></div><div class="public anchor" id="var-pipeline"><h3><a href="#var-pipeline">pipeline</a></h3><div class="usage"><code>(pipeline xform base sig)</code></div><div class="doc"><div class="markdown"><p>Takes a stateless transducer <code>xform</code>, a fallback value <code>base</code>, and a signal <code>sig</code>. Returns a new signal which pipes values from <code>sig</code> through <code>xform</code>. Because transducers may filter out values, you must provide a <code>base</code> which will be used as the derived signal&rsquo;s initial value if the initial value of <code>sig</code> ends up being filtered. If multiple values are emitted from the transduction of the initial value of <code>sig</code>, then the initial value of the new signal will be the <em>last</em> of those emitted. Stateful transducers will give unexpected results and are not supported.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L60">view source</a></div></div><div class="public anchor" id="var-reductions"><h3><a href="#var-reductions">reductions</a></h3><div class="usage"><code>(reductions f source)</code><code>(reductions f init source)</code></div><div class="doc"><div class="markdown"><p>Create a past-dependent signal like <code>foldp</code>, with two differences: * calls <code>f</code> with the arguments reversed to align with Clojure: the first argument is the accumulator, the second is the current value of <code>source</code>. * if <code>init</code> is omitted, the initial value of the new signal will be obtained by calling <code>f</code> with no arguments.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L176">view source</a></div></div><div class="public anchor" id="var-sample-on"><h3><a href="#var-sample-on">sample-on</a></h3><div class="usage"><code>(sample-on sampler-sig value-sig)</code></div><div class="doc"><div class="markdown"><p>Sample the current value of <code>value-sig</code> every time <code>sampler-sig</code> updates with a fresh value. For example, <code>(sample-on mouse/clicks mouse/position)</code> returns a signal of click positions.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L284">view source</a></div></div><div class="public anchor" id="var-select-step"><h3><a href="#var-select-step">select-step</a></h3><div class="usage"><code>(select-step init &amp; signals-and-handlers)</code></div><div class="doc"><div class="markdown"><p>Takes an initial value and a map whose keys are signals and whose values are reducing functions. Returns a past-dependent signal like <code>reductions</code>, except each signal has its own reducing function to use when that signal updates. If more than one source signal updates from the same input event, then each applicable reducing function is called to transform the state value in the same order as they are defined in <code>signal-handlers-map</code>.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L188">view source</a></div></div><div class="public anchor" id="var-spawn"><h3><a href="#var-spawn">spawn</a></h3><div class="usage"><code>(spawn s)</code><code>(spawn s opts)</code></div><div class="doc"><div class="markdown"><p>Take an inert signal and produce a live, running graph.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L393">view source</a></div></div><div class="public anchor" id="var-splice"><h3><a href="#var-splice">splice</a></h3><div class="usage"><code>(splice setup! source)</code><code>(splice setup! init-fn source)</code></div><div class="doc"><div class="markdown"><p>Splice into the signal graph on the level of core.async channels. Takes a <code>setup!</code> function which is called when the <code>source</code> signal gets wired up into a live graph. The <code>setup!</code> function is passed two arguments: a <code>from</code> channel and a <code>to</code> channel, in that order. The function is expected to be a consumer of the <code>from</code> channel and a producer on the <code>to</code> channel, and should close the <code>to</code> channel when the <code>from</code> channel is closed. There are no requirements for how many values should be put on the <code>to</code> channel or when they should be sent. <code>splice</code> returns a signal with an initial returned from <code>init-fn</code>. <code>init-fn</code> takes two functions, a <code>live-graph</code> and an <code>opts</code> map. If no <code>init-fn</code> is provided, then the initial value of <code>source</code> is used. The returned signal asynchronously produces whichever values are put on the <code>to</code> channel in the <code>setup!</code> function.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L228">view source</a></div></div><div class="public anchor" id="var-take-nothing"><h3><a href="#var-take-nothing">take-nothing</a></h3><div class="usage"><code>(take-nothing rf)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L46">view source</a></div></div><div class="public anchor" id="var-template"><h3><a href="#var-template">template</a></h3><div class="usage"><code>(template signal-map)</code></div><div class="doc"><div class="markdown"><p>Takes a map whose values are signals, to be used as a template. Returns a new signal whose values are maps of the same form as <code>signal-map</code>, but with the current value of each signal in place of the signal itself.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L112">view source</a></div></div><div class="public anchor" id="var-to-chan"><h3><a href="#var-to-chan">to-chan</a></h3><div class="usage"><code>(to-chan s &amp; args)</code></div><div class="doc"><div class="markdown"><p>Takes a signal <code>s</code> and returns a channel of fresh values, passing any extra <code>args</code> to the <code>chan</code> constructor.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L413">view source</a></div></div><div class="public anchor" id="var-write-port"><h3><a href="#var-write-port">write-port</a></h3><div class="usage"><code>(write-port init)</code><code>(write-port init topic)</code></div><div class="doc"><div class="markdown"><p>Takes an <code>init</code> value and an optional <code>topic</code>, and returns an input signal which satisfies core.async&rsquo;s <code>WritePort</code> protocol. This allows you to put values onto the signal as if it were a channel. If the <code>write-port</code> is being used in multiple live graphs, each value put onto the <code>write-port</code> is sent to all graphs.</p></div></div><div class="src-link"><a href="http://github.com/jamesmacaulay/zelkova/blob/master/src/jamesmacaulay/zelkova/signal.cljc#L32">view source</a></div></div></section></section></body></html>